import zlib
from enum import Enum

from numpy import uint8, array


class DESMode(Enum):
    DES_ENCRYPT = 'DES_ENCRYPT'
    DES_DECRYPT = 'DES_DECRYPT'


def bit_num(a: bytearray, b: int, c: int):
    byte_index = (b // 32) * 4 + 3 - (b % 32) // 8
    bit_position = 7 - (b % 8)
    extracted_bit = (a[byte_index] >> bit_position) & 0x01
    return extracted_bit << c


def bit_num_int_r(a: int, b: int, c: int) -> int:
    extracted_bit = (a >> (31 - b)) & 0x00000001
    return extracted_bit << c


def bit_num_int_l(a: int, b: int, c: int) -> int:
    extracted_bit = (a << b) & 0x80000000
    return extracted_bit >> c


def s_box_bit(a: int) -> int:
    part1 = (a & 0x20)
    part2 = ((a & 0x1f) >> 1)
    part3 = ((a & 0x01) << 4)
    return part1 | part2 | part3


s_box1 = array([
    14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7,
    0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8,
    4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0,
    15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13
], dtype=uint8)

s_box2 = array([
    15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10,
	3, 13, 4, 7, 15, 2, 8, 15, 12, 0, 1, 10, 6, 9, 11, 5,
    0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15,
    13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9
], dtype=uint8)

s_box3 = array([
    10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8,
    13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1,
    13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7,
    1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12
], dtype=uint8)

s_box4 = array([
    7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15,
    13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9,
    10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4,
    3, 15, 0, 6, 10, 10, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14
], dtype=uint8)

s_box5 = array([
    2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9,
    14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6,
    4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14,
    11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3
], dtype=uint8)

s_box6 = array([
    12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11,
    10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8,
    9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6,
    4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13
], dtype=uint8)

s_box7 = array([
    4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1,
    13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6,
    1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2,
    6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12
], dtype=uint8)

s_box8 = array([
    13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7,
    1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2,
    7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8,
    2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11
], dtype=uint8)


def ip(state: list, in_bytes: bytearray):
    state[0] = (
            bit_num(in_bytes, 57, 31) | bit_num(in_bytes, 49, 30) | bit_num(in_bytes, 41, 29) |
            bit_num(in_bytes, 33, 28) | bit_num(in_bytes, 25, 27) | bit_num(in_bytes, 17, 26) |
            bit_num(in_bytes, 9, 25) | bit_num(in_bytes, 1, 24) | bit_num(in_bytes, 59, 23) |
            bit_num(in_bytes, 51, 22) | bit_num(in_bytes, 43, 21) | bit_num(in_bytes, 35, 20) |
            bit_num(in_bytes, 27, 19) | bit_num(in_bytes, 19, 18) | bit_num(in_bytes, 11, 17) |
            bit_num(in_bytes, 3, 16) | bit_num(in_bytes, 61, 15) | bit_num(in_bytes, 53, 14) |
            bit_num(in_bytes, 45, 13) | bit_num(in_bytes, 37, 12) | bit_num(in_bytes, 29, 11) |
            bit_num(in_bytes, 21, 10) | bit_num(in_bytes, 13, 9) | bit_num(in_bytes, 5, 8) |
            bit_num(in_bytes, 63, 7) | bit_num(in_bytes, 55, 6) | bit_num(in_bytes, 47, 5) |
            bit_num(in_bytes, 39, 4) | bit_num(in_bytes, 31, 3) | bit_num(in_bytes, 23, 2) |
            bit_num(in_bytes, 15, 1) | bit_num(in_bytes, 7, 0)
    )
    state[1] = (
            bit_num(in_bytes, 56, 31) | bit_num(in_bytes, 48, 30) | bit_num(in_bytes, 40, 29) |
            bit_num(in_bytes, 32, 28) | bit_num(in_bytes, 24, 27) | bit_num(in_bytes, 16, 26) |
            bit_num(in_bytes, 8, 25) | bit_num(in_bytes, 0, 24) | bit_num(in_bytes, 58, 23) |
            bit_num(in_bytes, 50, 22) | bit_num(in_bytes, 42, 21) | bit_num(in_bytes, 34, 20) |
            bit_num(in_bytes, 26, 19) | bit_num(in_bytes, 18, 18) | bit_num(in_bytes, 10, 17) |
            bit_num(in_bytes, 2, 16) | bit_num(in_bytes, 60, 15) | bit_num(in_bytes, 52, 14) |
            bit_num(in_bytes, 44, 13) | bit_num(in_bytes, 36, 12) | bit_num(in_bytes, 28, 11) |
            bit_num(in_bytes, 20, 10) | bit_num(in_bytes, 12, 9) | bit_num(in_bytes, 4, 8) |
            bit_num(in_bytes, 62, 7) | bit_num(in_bytes, 54, 6) | bit_num(in_bytes, 46, 5) |
            bit_num(in_bytes, 38, 4) | bit_num(in_bytes, 30, 3) | bit_num(in_bytes, 22, 2) |
            bit_num(in_bytes, 14, 1) | bit_num(in_bytes, 6, 0)
    )
    return state


def inv_ip(state: list, in_bytes: bytearray):
    in_bytes[3] = (
            bit_num_int_r(state[1], 7, 7) | bit_num_int_r(state[0], 7, 6) |
            bit_num_int_r(state[1], 15, 5) | bit_num_int_r(state[0], 15, 4) |
            bit_num_int_r(state[1], 23, 3) | bit_num_int_r(state[0], 23, 2) |
            bit_num_int_r(state[1], 31, 1) | bit_num_int_r(state[0], 31, 0)
    )
    in_bytes[2] = (
            bit_num_int_r(state[1], 6, 7) | bit_num_int_r(state[0], 6, 6) |
            bit_num_int_r(state[1], 14, 5) | bit_num_int_r(state[0], 14, 4) |
            bit_num_int_r(state[1], 22, 3) | bit_num_int_r(state[0], 22, 2) |
            bit_num_int_r(state[1], 30, 1) | bit_num_int_r(state[0], 30, 0)
    )
    in_bytes[1] = (
            bit_num_int_r(state[1], 5, 7) | bit_num_int_r(state[0], 5, 6) |
            bit_num_int_r(state[1], 13, 5) | bit_num_int_r(state[0], 13, 4) |
            bit_num_int_r(state[1], 21, 3) | bit_num_int_r(state[0], 21, 2) |
            bit_num_int_r(state[1], 29, 1) | bit_num_int_r(state[0], 29, 0)
    )
    in_bytes[0] = (
            bit_num_int_r(state[1], 4, 7) | bit_num_int_r(state[0], 4, 6) |
            bit_num_int_r(state[1], 12, 5) | bit_num_int_r(state[0], 12, 4) |
            bit_num_int_r(state[1], 20, 3) | bit_num_int_r(state[0], 20, 2) |
            bit_num_int_r(state[1], 28, 1) | bit_num_int_r(state[0], 28, 0)
    )
    in_bytes[7] = (
            bit_num_int_r(state[1], 3, 7) | bit_num_int_r(state[0], 3, 6) |
            bit_num_int_r(state[1], 11, 5) | bit_num_int_r(state[0], 11, 4) |
            bit_num_int_r(state[1], 19, 3) | bit_num_int_r(state[0], 19, 2) |
            bit_num_int_r(state[1], 27, 1) | bit_num_int_r(state[0], 27, 0)
    )
    in_bytes[6] = (
            bit_num_int_r(state[1], 2, 7) | bit_num_int_r(state[0], 2, 6) |
            bit_num_int_r(state[1], 10, 5) | bit_num_int_r(state[0], 10, 4) |
            bit_num_int_r(state[1], 18, 3) | bit_num_int_r(state[0], 18, 2) |
            bit_num_int_r(state[1], 26, 1) | bit_num_int_r(state[0], 26, 0)
    )
    in_bytes[5] = (
            bit_num_int_r(state[1], 1, 7) | bit_num_int_r(state[0], 1, 6) |
            bit_num_int_r(state[1], 9, 5) | bit_num_int_r(state[0], 9, 4) |
            bit_num_int_r(state[1], 17, 3) | bit_num_int_r(state[0], 17, 2) |
            bit_num_int_r(state[1], 25, 1) | bit_num_int_r(state[0], 25, 0)
    )
    in_bytes[4] = (
            bit_num_int_r(state[1], 0, 7) | bit_num_int_r(state[0], 0, 6) |
            bit_num_int_r(state[1], 8, 5) | bit_num_int_r(state[0], 8, 4) |
            bit_num_int_r(state[1], 16, 3) | bit_num_int_r(state[0], 16, 2) |
            bit_num_int_r(state[1], 24, 1) | bit_num_int_r(state[0], 24, 0)
    )
    return in_bytes


def f(state: int, key: list) -> int:
    lrgstate = [0] * 6

    # Expansion Permutation
    t1 = (bit_num_int_l(state, 31, 0) | ((state & 0xf0000000) >> 1) | bit_num_int_l(state, 4, 5) |
          bit_num_int_l(state, 3, 6) | ((state & 0x0f000000) >> 3) | bit_num_int_l(state, 8, 11) |
          bit_num_int_l(state, 7, 12) | ((state & 0x00f00000) >> 5) | bit_num_int_l(state, 12, 17) |
          bit_num_int_l(state, 11, 18) | ((state & 0x000f0000) >> 7) | bit_num_int_l(state, 16, 23))

    t2 = (bit_num_int_l(state, 15, 0) | ((state & 0x0000f000) << 15) | bit_num_int_l(state, 20, 5) |
          bit_num_int_l(state, 19, 6) | ((state & 0x00000f00) << 13) | bit_num_int_l(state, 24, 11) |
          bit_num_int_l(state, 23, 12) | ((state & 0x000000f0) << 11) | bit_num_int_l(state, 28, 17) |
          bit_num_int_l(state, 27, 18) | ((state & 0x0000000f) << 9) | bit_num_int_l(state, 0, 23))

    lrgstate[0] = (t1 >> 24) & 0x000000ff
    lrgstate[1] = (t1 >> 16) & 0x000000ff
    lrgstate[2] = (t1 >> 8) & 0x000000ff
    lrgstate[3] = (t2 >> 24) & 0x000000ff
    lrgstate[4] = (t2 >> 16) & 0x000000ff
    lrgstate[5] = (t2 >> 8) & 0x000000ff

    # Key XOR
    for i in range(6):
        lrgstate[i] ^= key[i]

    # S-Box Permutation
    state = (s_box1[s_box_bit(lrgstate[0] >> 2)] << 28) | \
            (s_box2[s_box_bit(((lrgstate[0] & 0x03) << 4) | (lrgstate[1] >> 4))] << 24) | \
            (s_box3[s_box_bit(((lrgstate[1] & 0x0f) << 2) | (lrgstate[2] >> 6))] << 20) | \
            (s_box4[s_box_bit(lrgstate[2] & 0x3f)] << 16) | \
            (s_box5[s_box_bit(lrgstate[3] >> 2)] << 12) | \
            (s_box6[s_box_bit(((lrgstate[3] & 0x03) << 4) | (lrgstate[4] >> 4))] << 8) | \
            (s_box7[s_box_bit(((lrgstate[4] & 0x0f) << 2) | (lrgstate[5] >> 6))] << 4) | \
            s_box8[s_box_bit(lrgstate[5] & 0x3f)]

    # P-Box Permutation
    state = (bit_num_int_l(state, 15, 0) | bit_num_int_l(state, 6, 1) | bit_num_int_l(state, 19, 2) |
             bit_num_int_l(state, 20, 3) | bit_num_int_l(state, 28, 4) | bit_num_int_l(state, 11, 5) |
             bit_num_int_l(state, 27, 6) | bit_num_int_l(state, 16, 7) | bit_num_int_l(state, 0, 8) |
             bit_num_int_l(state, 14, 9) | bit_num_int_l(state, 22, 10) | bit_num_int_l(state, 25, 11) |
             bit_num_int_l(state, 4, 12) | bit_num_int_l(state, 17, 13) | bit_num_int_l(state, 30, 14) |
             bit_num_int_l(state, 9, 15) | bit_num_int_l(state, 1, 16) | bit_num_int_l(state, 7, 17) |
             bit_num_int_l(state, 23, 18) | bit_num_int_l(state, 13, 19) | bit_num_int_l(state, 31, 20) |
             bit_num_int_l(state, 26, 21) | bit_num_int_l(state, 2, 22) | bit_num_int_l(state, 8, 23) |
             bit_num_int_l(state, 18, 24) | bit_num_int_l(state, 12, 25) | bit_num_int_l(state, 29, 26) |
             bit_num_int_l(state, 5, 27) | bit_num_int_l(state, 21, 28) | bit_num_int_l(state, 10, 29) |
             bit_num_int_l(state, 3, 30) | bit_num_int_l(state, 24, 31))

    # Return the final state value
    return state


def des_key_setup(key: bytearray, schedule: list, mode: DESMode):
    key_rnd_shift = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1]
    key_perm_c = [56, 48, 40, 32, 24, 16, 8, 0, 57, 49, 41, 33, 25, 17,
                  9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35]
    key_perm_d = [62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21,
                  13, 5, 60, 52, 44, 36, 28, 20, 12, 4, 27, 19, 11, 3]
    key_compression = [13, 16, 10, 23, 0, 4, 2, 27, 14, 5, 20, 9,
                       22, 18, 11, 3, 25, 7, 15, 6, 26, 19, 12, 1,
                       40, 51, 30, 36, 46, 54, 29, 39, 50, 44, 32, 47,
                       43, 48, 38, 55, 33, 52, 45, 41, 49, 35, 28, 31]

    # Permutated Choice #1 (copy the key in, ignoring parity bits).
    c = 0
    d = 0
    for i in range(28):
        c |= bit_num(key, key_perm_c[i], 31 - i)
        d |= bit_num(key, key_perm_d[i], 31 - i)

    # Generate the 16 subkeys.
    for i in range(16):
        c = ((c << key_rnd_shift[i]) | (c >> (28 - key_rnd_shift[i]))) & 0xfffffff0
        d = ((d << key_rnd_shift[i]) | (d >> (28 - key_rnd_shift[i]))) & 0xfffffff0

        # Decryption subkeys are reverse order of encryption subkeys
        to_gen = 15 - i if mode == DESMode.DES_DECRYPT else i

        # Initialize the array
        schedule[to_gen] = [0] * 6
        for j in range(24):
            schedule[to_gen][j // 8] |= bit_num_int_r(c, key_compression[j], 7 - (j % 8))
        for j in range(24, 48):
            schedule[to_gen][j // 8] |= bit_num_int_r(d, key_compression[j] - 27, 7 - (j % 8))
    return 0


def des_crypt(input_bytes: bytearray, key_schedule: list):
    state = [0, 0]

    # Initial Permutation
    ip(state, input_bytes)

    for idx in range(15):
        t = state[1]
        i = f(state[1], key_schedule[idx])
        state[1] = i ^ state[0]
        state[0] = t

    # Perform the final loop manually as it doesn't switch sides
    state[0] = f(state[1], key_schedule[15]) ^ state[0]

    # Inverse Initial Permutation
    # output_bytes = inv_ip(state, output_bytes)
    inv_ip(state, input_bytes)
    return input_bytes


KEY1 = b"!@#)(NHLiuy*$%^&"
KEY2 = b"123ZXC!@#)(*$%^&"
KEY3 = b"!@#)(*$%^&abcDEF"


def func_des(buff: bytearray, key: bytes, length: int) -> bytearray:
    schedule = [[0] * 6 for _ in range(16)]
    des_key_setup(bytearray(key), schedule, DESMode.DES_ENCRYPT)
    output = bytearray()
    for i in range(0, length, 8):
        output += des_crypt(buff[i:i + 8], schedule)
    return output


def func_ddes(buff: bytearray, key: bytes, length: int) -> bytearray:
    schedule = [[0] * 6 for _ in range(16)]
    des_key_setup(bytearray(key), schedule, DESMode.DES_DECRYPT)
    output = bytearray()
    for i in range(0, length, 8):
        output += des_crypt(buff[i:i + 8], schedule)
    return output


def lyric_decode(content: bytearray, length: int) -> bytearray:
    content = func_ddes(content, KEY1, length)
    content = func_des(content, KEY2, length)
    content = func_ddes(content, KEY3, length)
    return content


if __name__ == '__main__':
    contents = "6B3F43A9B333C60F00066FDD48C343B2CCFDD36D1E5A73503851AB0B948520B4587604D9327F5EF00EC6D870177A3CE2DF6FF0BB1A5B5E60E4745687642352F8841ADA3B22F3D0B271299A11634286215A6305D475FEE49AD500DD47E2F27E6D2EE4B0C20504F85F3A81DF37A569569EA999D3D3901B7B7E84B074330F8D831C9218978665E1F50D986AFD7965D5A6B1CEAB84655687D104CFCC8CD5682718476AB0FEE2CB519F53CC051E1413D01A87C83DE20EC8F5A588EAA4FAF77D7867F65A537C8F5B40246B21EE1430CE945A5F72F91D2F1AB435048101B314C5E73D66D27072F103A5DCED25E2441B39992416E1C89EB32CDA5DADAE54064998F2CC6FF446C4F401384190AEC4AB2F8BE330AE75E79ACE30EDB6CFBD1C41893D0BF67AC9AE51D3DBABFB3191AE462ADC8C8873EB0B62BAB52AFD0CC3AA1A578C8BEEA8C161DEDEEC22CDD0EA53B25552F32632CE09ED77205862E8137BC16290E4FB4345AE4275151A176370DE09174C8A1D65C1ED878331B96C4D5EAC1138CE15BC1ED3A387C68B0DFDEFB6AB1F5E2310CFE3B888DC430FA11E8D4944AB3E265D346317144352B15117A23AE88DA82E437692686B9C73E5FC57E6D81519A05B9D29EF8264DACCD0A5FD074F24D6D18E636FB4D65163D067EB81A6AF9CD7FB8FB4D907987088EBE9FBBE0D9BF99A9A639FA6509D92A46B2EFA8E99DB431DBE95B67E887A9A482FC4C4842C648A7A349C1BE8F6744CD695E0E46E7B755EDD1F4F56CB00877FCB59058A1F0A82277D2E2248E215C19BD682E1D7ECE110874984FC4A96A95BA21E0CBEC34937156C148802ACCB00AF57F0CC6979CFD5A6B8CD2315344C4F3AFBAB557C9EAB570AF8D00EA19E5E374FF6B755C62BBDD7DFFC8C70DD4F7399A9E3FE36E95AD0CCA6E31F65218E867368411219F5256F173E84AC1898B7D6FB830FECCE058B619E35BA592F3740E8C34D13CAE428D20ADD8B19BA384BFE966247820B36D96E1EDF59E038252EE07674181E6EE9B578BF3DFE2CBC0E38AF43EFA54804DAC9EC785CB3CF82B6C5F05BF43CF513F51575828776FA7BB2CDE2F3469EAB4D56B365C4B8367959ECDEBEB3AF5732E4DF0B0350A41FF8C4DC54FC825CFF9E5977BF0C99319DCDDB72BAA50E59129CA6589B8D750BC77A87A0C6AF298FB19604221FDA1496B1A80B783CD38B1692A72D9A9A42E7493B16B706A23B072CE2A212D4F06C62C5717E3056A4240C304F39221BA2EC48B020D6D05036BE8F488A889D84E07ECC000C3DD3771EDC8D33EB4F45763E1E79C82BBCAC0623AA776535BA484D8F7A630D702AB4C37222C91F04D76EFC045DEA64707D4DE57604A7B9347E96FA201517705C853A93ACEB8BFE5492395D7D11782AD3CC8D6F976D0225A810BB7AB915E60DD18D87CFB6872CAE192DDFB969BFB0FC9DA779CEE821C868742EE54FE5613CFE70FA33BDA99A98682A2CBCB98949A79E3FCCCA0EA9D8905E8DB3C73E85F58139BCCD330C4FB8556647E1D498A76F6391C5A5020CC8FCCD467567875BAFAF931601EBEBE62B2FCDAB2F501F43BBD49334B0714125EA4794A5FC92987C90EF450AF75402416C438F8B9C458E07CC914BA86DA7D462B821BFFF11D35B1486590BDED5FF317AD59A60E4AF83FD8D4FEFE75F857F1E175ABC3621441C5B5EEA415108C935C61BED4112479E9FDB0FB64F16F90F9D717E187229B2D61D753DDBB987729EA683782E5C4C80DF0ACF54EF687BD6CFEB7074EFB210B4CADE49E58F46468A6E5ABC48B41F8995E77C5F104E418B6975B87FB96D00D95E0769DA36A63D201598507A8A70DFAC5A5C3ADE81EC0A6BC046C0C04AA6C514179458E086EA3ED10D6D1723A1197E6750D238205055C13502D93925DD7646C417F3DCB07053809D9906B12485718598E11BA6868C5DE6C38322EE674E2BA3987145DE41776A5B75D7083DC40C2B5C9A8A5A1496A13C71574A19B82C2114BA84AE0421BF3C71B5A25477506B1966BF0804A63E1CAA6EBEBC86952FDDACEA0C90D7DF21F8D24F1772093A9F85003B0BA773434D87924E541667FE432BD2BDF82ADA1DF297DC436BF945B377AF5D1671DDAF6BB0745FC434317C28EA55E00262B60AA57C3645235098338ABC750CD160AC417F0F541B50136915ED7EF044C0C435A920631637B6915468DE4768EC4656B8325F470AA7AD019C5C61508E986D94C5CC2B6B1605CB7C10D47F9FE55BC44F10FFB17269954972086F6F1677C256ADB897FB45856EEE8EB07F333E4A622326C97C77AD6DE8E9AA7310D2E98C64D048AE7DC9F538ED0D2CE8E9FD896A35210F7C1AD119B9AD64C0D0F9772312621207E6C8B1D9DF712AEB9CA61831650A7AF6D30EC43DD4EDA3AEA840AEDE641B1161BC2BD1D4C6C9888468FAD62D6BB86C994795D0C2C239E72AB6929F940171318DD9173852CCDAC7DB62937617881D41A436B76E1FDCA6C3C13C955ED97DA60CA96AB19AF3D3E6CE6C5645D547689A0BBA55029DB0541138ECA14BD0F6C766A51872598A89275E0B05CC1006D4931E94DDCE5E9A9A320BBE2AFE4BBE86F89CB17D7D0AAA1D6302044E609643211533FC8AFF116479135BF0B1FC911F62ABE98BAA6724044C2D75C8272DBA9AFC83738B016C65C33E1B4F861344390E22FAFDCFDEB3643DB70C4CFA8CE448702C4560E904271979729E60F54E8C33EF7D3612A57BF6BCD3DE58F677B5C16043582574E302ED4A29C2694A669FD4C6BAABD8DECA0FC523B13B4CB06A1E4F0CDD9B9CA4CD694937224CCB525A93285F9B6835CC37CA98002AD508645CA02EC57750BE550EDAB9AB5AA05082EB17E9EC178BDAB5ADCF51FED90DA8FBD164C06ADA4A72B07EDB141CF35EB62DDF3A1857D776EA0EABE4E31C06914AFBF914DD71658322D5573EBD33C5BF2F799261B4880B3816507A7173F787DA1FD5C78E1E38C20061A68FB244E89253049C0A8DB0139BEBEAF28192274173E66D8A988816920B19FF95C5EB0FA5EB5A6DB2DE0A7BE7ED4CEB5660416C19D0016C7639D1D2AA7714F78A5510BBB0C92B033CC47D9162FB4D92D55462E969806D4AA426557435167479CDCEC6FA58E5492C441E1AFBA8511488D25E6E757628B35C2CAA950F0BA0B5884D9DCEFC646D0CB2A218503447622BBCB52DAC0EDB28EA0BE15BCE6B20C6345B60C2D852D89B8D7FEE4AC60FCFE7A33AABEC10AA7DE2B187950760D652EEEFE30BD84D3B79DFBDA827493930F496563F69F3E6A0CB0EE732E4ABD012EE385C2D1DC0421128CFB98DE090696B3A062B766A6F24DB07D0B20304643F799585B007230B2C6EE3DCB91CDDAEB44C3DE480E2564F7ADF0C3C1D47F11330C55D19B89F753E7EA283CE2A2613454DEF0720D24A4B8396E855332F918EAEE82D073487B4504055686BFAF67E6F185C1D9ACC0A3AE84E7AA8D6015F4A14C87040EEF61522C0AC78AD55AA4953A34C1D070F19F1A65EC4C378336E69200ACDB0BD3E446448458030F7953D3D4C963DFC7E35F7197677078302B34AA877882A31F5D987DD02102DEE6EDA5B1293FB25CE5125EF0B96F0DC907ACDF2F60C7BC41605D8282CF2D0B96AE88EBE30D2580272A456455CCACA9DDDBA0EA68F0D4B2CBCDA70FF4F9DA2CDAF9F6DD7B44056469EA3A9DDEDBA3A8E5DFBB2B9FA10407B5D2D0F12B51D576BB50688D90381726C462B0EFD1CF8769DDEC1519220A9590864C5D6B938E3066CC88160073CB8705A284A04997387F758E1B84ACFF115C179D5BECD61D4E045DC433AB4140278BCB4A72074C1F8D61135DDE26C9E5EE35154C70093CFF6E029853FDB97B51CE295F21B6A87FD5C0D9EAFD599BE316DD621B8460DC88CC7436A48C5045FDEF9DF3E65CD9186B5B56F7B200C48341E0DD8C317C21C4131930DBBBEAEACD1BA3374CB040942040B561C209DC6E0FAEBCFC01801CB3D7D26889E4333CDA4B747AAF10ACE09A705E86A4A433FB9EFD3AC9733092C5BEA5EA8719A039700A608AED52C9E6CA89AE23BEBFDB6FC9801162CB5F73833EC998B8519A7AEBF2FFBE6D31922795097FF782A274ECD866CEC25DAFF88118D9527467D044812E5A77189832C09936FB71555CFFAC956C79938D93AABF855E47E09CE2F7CECCE2B358A94310DEE53E4ABDE77A991456499E77041929BBDA0426031972AE50881C634D40A6B503BE82CE3CF49E3DF97B63C2B999BF17B75517D10A2851ECA4AD12C3FDF4BB1E0D8A65864F4AF9AB122D1F1CD5BB842F9CE1425AF5F5C8D580958E0862936F04555A885ACBBFE8D50A13CB6C04FD12300391D44D681407F6B666698FD25112A1899D1AFB7D5391E8E47B581020D06E67505A7A7D621C50BCB3E577D48A38498761CE29EAD3399C6B13227EBD281AB2E9A5195FE9486E5A0AEE01EA445035A1D195313DA9058A3192972F6102A03B9501DDA1EB31AAB927A1E47E0B5822FD22E64C7F6BCF66E22001AFEB98DD1D5023DECDA1F067AAC0F02F3409CA56B5063C3425C6B52E587D7225CBA23C361ECA7780D6E624102F1FC4E2EB20D5F791A50497A3A28ABD9AAA0EEDD934C3555FC6BCFBA541BA7D9F115E86A9174EFCCDE08E15D16A3FA27C0F6AC5ECE99B18D2766C9F2A9D2BB56ED0B932F21B4AD89031858942E0FD13ED8C28E555FDE1E97D37006779B3A6123BD01F19F5A37585A3C177D75A1457C6EB78474F23442D47506CEE45F43DC5E56DA7D41F44435E037FEB83EBB7F8C6FBD95E7A85828FD10EB10EF4CDA98DC87ADADD2C71B6B40DDAEFC762034503832A4C620D8F51497091B369DF9BAA7B5761E29F9F1C9BC2F977DB61EC8FD58B5C902D782DA83F4E8999E0BF3D09792041488A64A5C95C28DFB158CE7BF24A5EFEC5A376A5E5999C98C05C80B7149BF18DA6B253A50C95447B3066334734C0BA86A25E1208D3AD0ECE3B03ECAC341FEE711086CB442D7321AD198BDDC06603E5AFD13CB17EFF393F385470F45CA64FBD8035959E71D6088422C0A5DC7FF2C075A74C8BA5AB4EF8DF8686F69D6F80E73ED84A201074C955D22A4FA0FD57AA7840F72D453C22629EF92551CE1C1EBC60D264AB0AD0E83F82CC15D23670A2BD025B53659ADFC7E51F2E09BDADA10A0E71F6949368D79C2C594F1391B139541C8FAC628B3BF6BC602BA03C7466E66F3450B92E4A06134211014D75A602F462F0F46D0FDCE7CBB4C64372C957BB1BDFD04E2ECE863D15B9CB3A9E8361B9081094C3C27BDA4C9A0611A6355C86362BCC376551BA18252A513437E6D96991800282520870DB3256E5C407A35A668E1F14ADD46A6D9A585CC98CF545DB7B3E9DA1F10642F93700CD07A9760F8E26DE6F9DD860596F0D761B4830F56AD9719377265823CCEB86A456B9B4AA669D7D47BCBE67584B3BC598AD9CEFEC44E9B81AFC1B56A29F4DF45F7DFDD0FCDDAE8F1CB9EFA8139CA99D3EDD6DF2EF1EA6A0F52EEFBE3C634036822EF53A3A15965076CF2E88EB06EB81853250FA5C8D572A697E0B1AE333C9DA4853AECEFC109CD8A2B491D60DF55FE4C6811687653D25B3BFC77552D40889956F86D13578E4EFCF560D225E941FA2DAEB80A991A14BA2E81BD0564AA39E342BDCEC5E0CFA097AAEAD971E8934BE3D98388EEBA9BF6203136FD9FBBDE63ED1EDEFCF069F74406523F0B55703F33E5FB5E0596BF7F36C79832F809E70597696F2751268069717508190E094D1E2C316765E8348EEC7A8DA3A29914454A6EC9E7BA40C0FEED7323DF55D2004AC1BD0C2EF31EB271B1EFED29865765718DEE0CCB55FB55968D31BDF074A81B681A586D953B9BDF6263FBD5EAFE53AD7DD4E3FFC824BCAA1C756FBB543F3B79206F4016BBD583443F28AB89DA73135B406A7D86788A4579BBD87400916D559DFFB393836CEB78A8B69AB0ECEA6AA5E45214AA3E6EBD01DE56B4579E6A25441F4D679F7FD4A2046832A5C7870E5D8217198EBD04A9938D6CCCF0156E82B647F82DD4FCFE5234B5C970F9AA3AB5B1675EB507F2D4165F62D5ACFD06D84B28B508EE2872919E132FDEC9E1AF6798EF9F48AE014F50996394F7AB7512D43AC07FA3651FB4AC877747BB7A921618712CDB71600A71E82D0991195A6B8090F180430DCF70FA362107AA39CBFFF5343DFA5EE436B8E807CDB1ECCA582AA7BD238DA70D3AE94B20C02D81B626BB294089B53E520D99248BBCD36B95A9BD5E3E1B5C1D91CED00EEAB11E4FE4D0E64746E2D5566FFE40F51B020E120FED6896766CEC9CA665C074B131C3E742A9A2BB5F0542C0C02CBBD596184B0D9651C531CBB5DBD5934E8D1ADF2588FCD87D38E57422EC289238D80E03E67C5B8D25055C942AD4D805273F58E764ED87B44A134BB739BFADAAAF3674E53B7BE231893C5A3FFDE5143B19A6C1EBAA30C8C8DE6F6F9C5A905E0CE3C22789C8EBFBF0E16CD4E67A17B7F470417C5939ABAD35287F826F0A209C45416F858AEA775AF323B16436BC33F67C754DFE871DF5E241A167E98B66962455D29535397BBE7732F1597906C3762EDAF7000526807FA13893FC9FF127F81E187130C45DE5130BE7C66BAA6C173B2A6AC32A990BC391D25A168ADB4EB9537B95AF44167EB05F67D7A1159F0B922A88DC8725C214A1836C48FD2710B7959303B88298D0AC863FCFABA10023263D4A53F5AABA0C4A36FC4120BBBCD36C758344549F1DE32300DD53EBB344BAD7600E7634BC95306DA59B813689090FAA0CC61F000586F949D8981A26597ABBCF185F9CC5F2E5CA2608C5ED0C4BA215A09F71EFEE359EFA4EA34711694E1D3A4EA588C78EA9B6F1146C5FD62230C65774FCBAD70B21A9B7961051F38A9C3B8503ECF82444116B5E25B0995EA5D01A4AF845636AB647B93ABF7F28B317CAE4C7787A0A941A0BBCD9886E0D54639313780763180D148E3237A8AB36BB274EC11F47C049B091E2F0C1852A848B92CCB661CD7A397C051EBDBBB1D99C87761E22C5F7953014F990374F30A64C3395702DC34AC5E220A2F674E04BC9D84556B00AFA0846427D759E8713F4C0D446E79C41426AE0C81B3591D0F55068C70C6CB473D81667613A5ADD3A3FF48AF6AC49576F09CECC535B8AFB5E7605E31A00BD7118A697AD1BA8E455CDC4C9F045CEF5AB55A352E08B65A0474A632908D08A3396C45A676FA16DEE227787B3AFAFB8AFBD180DE33BD1BF19765E98F45ADCA04736961316C6603852FEAA3A5E5FA3FEC7893FC6BF339CC5FFDBE942EC18C4733B8575C335353BA4DE02644B6A7345662F3621E781C88A8646E89DD71F6D4F2D766A2BF562F58B0F715290C275D88B837F40C728329D9804E6301EA50D7C868616E16B4A9BD2F01D6A9C6986F1E71474FE276AA21D52CF6A7E1CC625005A872A0C7775B3D93D768E6A9EA7437E8733F958EDCAF99C6CE2A5B90232C6594797EF0B250B2B92ABD7E7F5B68CD042CF125AC71D6AE81C3BE62FA4792C1FD7245FDC250DBD09F92B072B9781AB9981D8BC4BE66AB17ED0343FF68E65F81489AF2E9479B563008A986C1E1772EFEA4FEB12611B6747691084F0177FCB2E6226FA354FB19FC9712031C070028416C2BB348710A9A33915CE1E7A679C9FC284DF29B7C59454429C28E5EA57A1E2861EEA9BE36B729D54EEAFAC4FD41975E99BB536B45BD2310B81E4BB61A27233D7820BE8A42DF5B0883427AAF1CA9A1D0D434453B22A0CAE49B68ECD88BD13AA3344B711725FF40846C98AA40A1E64098C15DDF74E31A81E9EB1B77DCFB74C53E0A59CC1D54E1C303014E31E38D287E367957B51FC2466A14B015BC11A53186C33B99066753F7A020109BD3DF40BB12AE4409FFF45E8D8479C72EE3E8547DC1C62D87C040ECEB86445285AA11293B4C9E18350B71C625DD5DE85501885802D2F5E04EB0F8B3CAF9E2C1463CCF4DA83564589C95A1338C935987BBB5B41D958690398612E7834A1B01CAB9B6E6C41A6749E9E2D5E46329A0C7C9EA63BC3CFD8922365EA54835D92057CC0B73F41CFEE8BCAC2E41F450FE831B0EA1528A29B6799CCD946DB0A2C549801F0FA0D00FB2F7B632414C019315D63C037569A92E93B0516DAA26167FB1903E271AF6E91B6F6386331AF9F9C311D35D2DD48EE9C36CE677A3ECE7C376714003C58E02FEC6E70BA4D61B787F999C4D11B39B5B4A88CC1C84A7CDC59E24956B823FDE6D25C54185B56BC188BEBAA262CA84C17BEB4EC03768E70A28D74D250"
    contents = bytearray.fromhex(contents)
    contents = lyric_decode(contents, len(contents))
    un = zlib.decompress(contents)
    print(un.decode())
